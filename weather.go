package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/nathan-osman/go-sunrise"
)

type UserAgentTransport struct {
	http.RoundTripper
}

func (c *UserAgentTransport) RoundTrip(r *http.Request) (*http.Response, error) {
	r.Header.Set("User-Agent", `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36`)
	return c.RoundTripper.RoundTrip(r)
}

func DisplayWeather(cfg *Config, w Writer) {
	if cfg.WeatherLat == 0 && cfg.WeatherLon == 0 {
		return
	}

	weatherStr := getWeather(cfg.WeatherLat, cfg.WeatherLon)
	if weatherStr != "" {
		w.Write(weatherStr)
	}
}

func DisplaySunriseSunset(cfg *Config, w Writer) {
	if !cfg.SunriseSunset || cfg.WeatherLat == 0 || cfg.WeatherLon == 0 {
		return
	}

	now := time.Now()
	rise, set := sunrise.SunriseSunset(
		cfg.WeatherLat, cfg.WeatherLon,
		now.Year(), now.Month(), now.Day(),
	)

	w.Write(fmt.Sprintf("ğŸŒ… %s ğŸŒ‡ %s\n", rise.Local().Format("15:04"), set.Local().Format("15:04")))
}

func getWeather(lat, lon float64) string {
	client := &http.Client{
		Transport: &UserAgentTransport{http.DefaultTransport},
		Timeout:   10 * time.Second,
	}

	url := fmt.Sprintf("https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=%.2f&lon=%.2f", lat, lon)
	resp, err := client.Get(url)
	if err != nil {
		fmt.Printf("Error fetching weather: %v\n", err)
		return ""
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("Error reading weather response: %v\n", err)
		return ""
	}

	var res AutoGenerated
	if err := json.Unmarshal(body, &res); err != nil {
		fmt.Printf("Error parsing weather data: %v\n", err)
		return ""
	}

	if len(res.Properties.Timeseries) == 0 {
		return ""
	}

	temperature := res.Properties.Timeseries[0].Data.Instant.Details.AirTemperature
	symbolCode := res.Properties.Timeseries[0].Data.Next12Hours.Summary.SymbolCode
	weatherEmoji := determineWeatherEmoji(symbolCode)

	return fmt.Sprintf("# %dÂ°C %s\n", int(temperature+0.5), weatherEmoji)
}

func determineWeatherEmoji(desc string) string {
	switch {
	case strings.Contains(desc, "cloudy") || strings.Contains(desc, "partlycloudy_day"):
		return "â˜ï¸"
	case strings.Contains(desc, "rain") || strings.Contains(desc, "heavyrain"):
		return "ğŸŒ§"
	case strings.Contains(desc, "snow"):
		return "â„ï¸"
	case strings.Contains(desc, "clearsky_day"):
		return "â˜€ï¸"
	case strings.Contains(desc, "storm"):
		return "â›ˆ"
	case strings.Contains(desc, "clearsky_night"):
		return "ğŸŒ™"
	case strings.Contains(desc, "sleet"):
		return "ğŸŒ§ï¸â„ï¸"
	case strings.Contains(desc, "fair_night") || strings.Contains(desc, "fair_day"):
		return "ğŸŒ¤"
	default:
		fmt.Printf("Unknown weather symbol: %s\n", desc)
		return ""
	}
}

type AutoGenerated struct {
	Type     string `json:"type"`
	Geometry struct {
		Type        string    `json:"type"`
		Coordinates []float32 `json:"coordinates"`
	} `json:"geometry"`
	Properties struct {
		Meta struct {
			UpdatedAt time.Time `json:"updated_at"`
			Units     struct {
				AirPressureAtSeaLevel string `json:"air_pressure_at_sea_level"`
				AirTemperature        string `json:"air_temperature"`
				CloudAreaFraction     string `json:"cloud_area_fraction"`
				PrecipitationAmount   string `json:"precipitation_amount"`
				RelativeHumidity      string `json:"relative_humidity"`
				WindFromDirection     string `json:"wind_from_direction"`
				WindSpeed             string `json:"wind_speed"`
			} `json:"units"`
		} `json:"meta"`
		Timeseries []struct {
			Time time.Time `json:"time"`
			Data struct {
				Instant struct {
					Details struct {
						AirPressureAtSeaLevel float64 `json:"air_pressure_at_sea_level"`
						AirTemperature        float64 `json:"air_temperature"`
						CloudAreaFraction     float64 `json:"cloud_area_fraction"`
						RelativeHumidity      float64 `json:"relative_humidity"`
						WindFromDirection     float64 `json:"wind_from_direction"`
						WindSpeed             float64 `json:"wind_speed"`
					} `json:"details"`
				} `json:"instant"`
				Next12Hours struct {
					Summary struct {
						SymbolCode string `json:"symbol_code"`
					} `json:"summary"`
				} `json:"next_12_hours"`
				Next1Hours struct {
					Summary struct {
						SymbolCode string `json:"symbol_code"`
					} `json:"summary"`
					Details struct {
						PrecipitationAmount float64 `json:"precipitation_amount"`
					} `json:"details"`
				} `json:"next_1_hours"`
				Next6Hours struct {
					Summary struct {
						SymbolCode string `json:"symbol_code"`
					} `json:"summary"`
					Details struct {
						PrecipitationAmount float64 `json:"precipitation_amount"`
					} `json:"details"`
				} `json:"next_6_hours"`
			} `json:"data"`
		} `json:"timeseries"`
	} `json:"properties"`
}
